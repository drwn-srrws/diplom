---
MainTheme: "Типи даних"

PageThemes:
  [
    { name: "Число (number)", url: "chislo-number" },
    { name: "BigInt", url: "bigint-type" },
    { name: "Рядок (string)", url: "ryadok-string" },
    {
      name: "Булевий або логічний тип (boolean)",
      url: "bulevii-abo-logichnii-tip-boolean",
    },
    { name: "Значення “null”", url: "znachennya-null" },
    { name: "Значення “undefined”", url: "znachennya-undefined" },
    {
      name: "Об’єкти (object) та символи (symbol)",
      url: "obyekti-object-ta-simvoli-symbol",
    },
    { name: "Оператор typeof", url: "type-typeof" },
    { name: "Підсумки", url: "pidsumki" },
  ]
---

<Column>
# Типи даних

Значення в JavaScript завжди має певний тип даних. Наприклад, рядок або число.

У JavaScript є вісім основних типів даних. У цьому розділі ми розглянемо їх в цілому, а в наступних — детально поговоримо про кожен з них.

Ми можемо призначити змінній будь-який тип даних. Наприклад, в один момент змінна може бути рядком, а в інший – числом:

<Code>

1. **// тут не буде помилки**
2. `let message = "привіт";`
3. `message = 123456;`

</Code>

Мови програмування, які дають змогу таке робити, називаються “динамічно типізованими”. Мається на увазі, що типи даних визначені, але змінні не прив’язанні до жодного типу.

</Column>

<Column id="chislo-number">
## Число (number)

<Code>

1. `let n = 123;`
2. `n = 12.345;`

</Code>

Тип _number_ представляє і цілі числа, і числа з рухомою точкою.

Є багато операцій, що можна робити з числами, наприклад, множення `*`, ділення `/`, додавання `+`, віднімання `-` тощо.

Окрім звичайних чисел, є так звані “спеціальні числові значення”, що також мають відношення до цього типу даних: `Infinity`, `-Infinity` і NaN`.

Infinity являє собою математичну нескінченність ∞. Це спеціальне значення, що є більшим за будь-яке число.

Ми можемо отримати його як результат ділення на нуль:

<Code>

1.  `alert(1 / 0);` **// Infinity;**

</Code>

Або безпосередньо посилатися на нього:

<Code>

1. `alert(Infinity);` **// Infinity**

</Code>

NaN (Not a Number) являє собою помилку обчислення. Це є результат неправильної або невизначеної математичної операції, наприклад:

<Code>

1. `alert("not a number" / 2);` **// NaN, таке ділення є помилковим**

</Code>

NaN є “причепливим” (“заразливим”). Будь-яка подальша математична операція з NaN повертає NaN:

<Code>

1. `alert( NaN + 1 ); ` **// NaN**
2. `alert( 3 * NaN );` **// NaN**
3. `alert( "not a number" / 2 - 1 );` **// NaN**

</Code>

Отже, якщо десь у математичному виразі є `NaN`, він поширюється на весь результат (є лише один виняток: результатом операції `NaN ** 0` буде `1`).

<Extra>
### Математичні операції є безпечними
 
Обчислення є “безпечним” в JavaScript. Ми можемо робити будь-що: ділити на нуль, звертатися до нечислового рядка як до числа тощо.

Виконання скрипта ніколи не зупиниться з фатальною помилкою (не “вмре”). У найгіршому випадку ми отримаємо в результаті `NaN`.

</Extra>

Спеціальні числові значення формально належать до типу “number”. Хоча, звісно, вони не є числами у загальноприйнятому розумінні.

Докладніше роботу з числами ми розглянемо у розділі Числа.

</Column>

<Column id="bigint-type">
## BigInt

У JavaScript, тип “number” не може містити числа більші за `(2^53-1)` (це `9007199254740991`), або менші за `-(2^53-1)` для від’ємних чисел. Це технічне обмеження, спричинене їхньою внутрішньою реалізацією.

Для більшості потреб цього достатньо, але бувають випадки, коли нам потрібні дійсно великі числа, наприклад, для криптографії або мікроксекундних часових міток (timestamps).

Нещодавно в мову був доданий тип `BigInt` для представлення цілих чисел довільної довжини.

Значення з типом `BigInt` створюється через додавання n у кінець цілого числа:

<Code>

1. **// буква "n" у кінці означає, що це число типу BigInt**
2. `const bigInt = 1234567890123456789012345678901234567890n; `

</Code>

Через те, що тип BigInt рідко використовується, ми не розглядатимемо його в цьому розділі, проте ми винесли його в окремий розділ BigInt. Прочитайте його, якщо вам потрібні такі великі числа.

<Extra>
### Проблеми із сумісністю

Цієї миті, підтримка типу BigInt є в останніх версіях Firefox/Chrome/Edge/Safari, але не в IE.

</Extra>

На сайті MDN є [таблиця сумісності](https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Global_Objects/BigInt#%D0%A1%D1%83%D0%BC%D1%96%D1%81%D0%BD%D1%96%D1%81%D1%82%D1%8C_%D0%B7_%D0%B2%D0%B5%D0%B1-%D0%BF%D0%B5%D1%80%D0%B5%D0%B3%D0%BB%D1%8F%D0%B4%D0%B0%D1%87%D0%B0%D0%BC%D0%B8), де показано, які версії браузерів підтримують тип `BigInt`.

</Column>

<Column id="ryadok-string">
## Рядок (string)

Рядок у JavaScript має бути оточений лапками.

<Code>

1. `let str = "Привіт";`
2. `let str2 = 'Одинарні лапки також дозволяються';`
3. ` let phrase = ``так можна вставляти  ` ` ${str}```;  `

</Code>

У JavaScript є три типи лапок.

- Подвійні лапки: "Привіт".
- Одинарні лапки: 'Привіт'.
- Зворотні лапки: `Привіт`.

Подвійні та одинарні лапки є “звичайними”. Тобто немає ніякої різниці, які саме використовувати.

Зворотні лапки є розширенням функціональності. Вони дають змогу вбудовувати змінні та вирази в рядок, обрамляючи їх в `${…}`, наприклад:

<Code>

1. `let name = "Іван";`
2.
3. `// вбудована змінна`
4. ` alert(``Привіт, ${name}е!``);` **// Привіт, Іване!**
5.
6. `// вбудований вираз`
7. ` alert(``результат: ${1 + 2}``);` **// результат: 3**

</Code>

Вираз всередині `${…}` обчислюється, а результат обчислення стає частиною рядка. Ми можемо вбудувати будь-що: змінну `name`, або арифметичний вираз `1 + 2`, або щось набагато складніше.

Будь ласка, зауважте, що вбудовування можна робити тільки зі зворотніми лапками. Інші типи лапок не мають функціональності вбудовування!

<Code>

1. `alert("результат: ${1 + 2}"); `**// результат: ${1 + 2} (подвійні лапки не мають ніякого впливу)**

</Code>

Більш детально ми будемо висвітлювати рядки в розділі Рядки.

<Extra>
## Немає типу символ (character).

У деяких мовах є спеціальний тип “character” для позначення єдиного символу. Наприклад, у мовах C та Java це `char`.

У JavaScript немає такого типу. Є єдиний тип: `string`. Рядок може містити нуль символів (бути пустим), один символ або більше.
</Extra>

</Column>

<Column id="bulevii-abo-logichnii-tip-boolean">
## Булевий або логічний тип (boolean)

Логічний тип може приймати лише два значення: `true` (істина) та `false` (хиба).

Цей тип зазвичай використовується для зберігання значень так/ні: `true` означає “так, вірно”, а `false` означає “ні, не вірно”.

Наприклад:

<Code>

1. `let nameFieldChecked = true;` **// так, ім’я було перевірене;**
2. `let ageFieldChecked = false;` **// ні, вік не був перевіреним**

</Code>

Логічне значення також можна отримати як результат порівняння:

<Code>

1. `let isGreater = 4 > 1;`
2.
3. ` alert(isGreater);` **// true (результат порівняння — "так")**

</Code>

Більш глибоко ми охопимо булеві значення у розділі Логічні оператори.

</Column>

<Column id ="znachennya-null">
## Значення “null”

Спеціальне значення `null` не належить до жодного з описаних вище типів.

Воно формує окремий власний тип, який містить лише значення `null`:

<Code>

1. `let age = null;`

</Code>

В JavaScript `null` не є “посиланням на неіснуючий об’єкт” або “покажчиком на null”, як може бути в інших мовах програмування.

Це лише спеціальне значення, яке представляє “нічого”, “порожнє” або “невідоме значення”.

У наведеному вище коді зазначено, що значення змінної `age` невідоме.

</Column>

<Column id ="znachennya-undefined">
## Значення “undefined”

Спеціальне значення `undefined` також стоїть окремо. Воно представляє власний тип, подібний до “null”.

`undefined` означає, що “значення не присвоєно”.

Якщо змінна оголошена, але їй не присвоєне якесь значення, тоді значення такої змінної буде `undefined`:
<Code>

1. `let age;`
2.
3. `alert(age);` **// покаже "undefined"**

</Code>

Технічно, є можливість явно призначити undefined змінній:

<Code>

1. `let age = 100;`
2.
3. **// змінюємо значення на undefined**
4. `age = undefined;`
5.
6. `alert(age);` // **"undefined"**

</Code>

…Але ми не рекомендуємо так робити. Як правило, ми використовуємо `null`, щоби присвоїти змінній значення “порожнє” або “невідоме”, тоді як undefined зарезервоване для позначення початкового значення для неприсвоєних речей.

</Column>

<Column id ="obyekti-object-ta-simvoli-symbol">
## Об’єкти (object) та символи (symbol)

Тип object є особливим типом.

Усі інші типи називаються “примітивами”, тому що їхні значення можуть містити тільки один елемент (це може бути рядок, число, або будь-що інше). В об’єктах же зберігаються колекції даних і більш складні структури.

Об’єкти є важливою частиною мови, тому ми окремо розглянемо їх у розділі Об’єкти після того, як дізнаємося більше про примітиви.

Тип `symbol` використовується для створення унікальних ідентифікаторів в об’єктах. Ми згадали цей тип для повноти, проте докладніше вивчимо його після об’єктів.

</Column>

<Column id ="type-typeof">
## Оператор typeof

Оператор `typeof` повертає тип аргументу. Це корисно, коли ми хочемо обробляти значення різних типів по-різному або просто хочемо зробити швидку перевірку.

Виклик `typeof x` повертає рядок із назвою типу:

<Code>

1. `typeof undefined` **// "undefined"**
2.
3. `typeof 0` **// "number"**
4.
5. `typeof 10n` **// "bigint"**
6.
7. `typeof true` **// "boolean"**
8.
9. `typeof "foo"` **// "string"**
10.
11. `typeof Symbol("id")` **// "symbol"**
12.
13. `typeof Math` // **"object" (1)**
14.
15. `typeof null` **// "object" (2)**
16.
17. `typeof alert` **// "function" (3)**

</Code>

Останні три рядки можуть потребувати додаткового пояснення:

- `Math` — це вбудований об’єкт, який забезпечує математичні операції. Ми вивчимо його в розділі Числа. Тут він використаний лише як приклад об’єкта.
- Результатом `typeof null` є `"object"`. Це офіційно визнана помилка поведінки typeof, що є ще з ранніх днів JavaScript і зберігається для сумісності. Безперечно, `null` не є об’єктом. Це особливе значення з власним типом. У цьому разі поведінка typeof некоректна.
- Результатом `typeof alert` є `"function"`, тому що `alert` — це функція. Ми будемо вивчати функції в наступних розділах, де ми також побачимо, що в JavaScript немає спеціального типу “function”. Функції належать до типу “об’єкт”. Але `typeof` трактує їх по-іншому, повертаючи `"function"`. Це також присутнє з ранніх днів JavaScript. Технічно, така поведінка не зовсі

<Extra>
### Синтаксис `typeof(x)`

Можливо ви зустрічали інший синтаксис: `typeof(x)`. Це те саме, що `typeof x`.

Щоби було зрозуміло: `typeof` – це оператор, а не функція. Тут дужки не є частиною `typeof`. Це щось на кшталт математичних дужок для групування.

Зазвичай, такі дужки містять математичні вирази, як `(2 + 2)`, але тут вони містять лише один аргумент `(x)`. Ці дужки дають змогу опустити пробіл між оператором `typeof` та його аргументом, і декому це подобається.

Тому вони надають перевагу синтаксису `typeof(x)`, проте синтаксис `typeof x` набагато поширеніший.

</Extra>

</Column>

<Column id ="pidsumki">
## Підсумки

У JavaScript є 8 основних типів.

- `number` для будь-яких чисел: цілих або з рухомою точкою; цілі числа обмежені до `±(2^53-1).`
- `bigint` для цілих чисел довільної довжини.
- `string` для рядків. Рядок може мати нуль або більше символів, немає окремого типу для одного символу.
- `boolean` для `true/false`.
- `null` для невідомих значень — автономний тип, який має єдине значення `null`.
- `undefined` для неприсвоєних значень — автономний тип, який має єдине значення `undefined`. object для більш складних структур даних.
- `symbol` для унікальних ідентифікаторів.

Оператор typeof дає змогу нам бачити, який тип зберігається в змінній.

- Зазвичай використовують синтаксис `typeof x`, проте `typeof(x)` також можливий.
- Повертає рядок із назвою типу, як-от `"string"`.
- Для `null` повертає `"object"` —- це помилка в мові, null насправді не об’єкт.

У наступних розділах ми зосередимося на примітивних значеннях, а коли ознайомимося з ними, то перейдемо до об’єктів.

</Column>
