---
MainTheme: "Базові оператори, математика"

PageThemes:
  [
    {
      name: "Терміни: “унарний”, “бінарний”, “операнд”",
      url: "termini-unarnii-binarnii-operand",
    },
    { name: "Математика", url: "matematika" },
    {
      name: "Об’єднання рядків через бінарний +",
      url: "obyednannya-ryadkiv-cherez-binarnii",
    },
    {
      name: "Числове перетворення, унарний +",
      url: "chislove-peretvorennya-unarnii",
    },
    { name: "Пріоритет оператора", url: "prioritet-operatora" },
    { name: "Присвоєння", url: "prisvoyennya" },
  ]

Test: "true"
---

<Column>
# Базові оператори, математика

Зі шкільної програми ми знаємо багато арифметичних операцій, таких як додавання +, множення \*, віднімання - тощо.

У цьому розділі ми почнемо з простих операторів, потім зосередимося на специфічних для JavaScript аспектах, які не охоплені шкільною арифметикою.

</Column>

<Column id="termini-unarnii-binarnii-operand">
## Терміни: “унарний”, “бінарний”, “операнд”

Перш ніж ми почнемо, давайте розберемо певну загальну термінологію.

Операнд – це те, до чого застосовуються оператори. Наприклад, у множенні `5 * 2` є два операнди: лівий операнд `5` і правий операнд `2`. Іноді їх називають “аргументами”, а не “операндами”.

Оператор є унарним, якщо він має один операнд. Наприклад, унарне заперечення `-` змінює знак числа:

<Code>

1. `let x = 1;`
2.
3. `x = -x;`
4. `alert( x );` **// -1, було застосоване унарне заперечення**

</Code>

Оператор є бінарним, якщо він має два операнди. Наприклад, оператор мінус можна використовувати і у бінарній формі:

<Code>

1. `let x = 1, y = 3;`
2. `alert( y - x );` **// 2, бінарний мінус віднімає значення**

</Code>

Формально, у прикладах вище ми маємо два різні оператори, які позначаються однаковим символом: оператор заперечення – унарний оператор, який змінює знак числа, та оператор віднімання – бінарний оператор, який віднімає одне число від іншого.

</Column>

<Column id="matematika">
## Математика

JavaScript підтримує такі математичні операції:

Додавання `+`,
Віднімання -,
Множення `*`,
Ділення `/`,
Остача від ділення `%`,
Піднесення до степеня `**`.
Перші чотири операції зрозумілі, а от про `%` та `**` потрібно сказати декілька слів.

### Остача від ділення %

Оператор остачі `%`, попри свій зовнішній вигляд, не пов’язаний із відсотками.

Результатом `a % b` є остача цілочислового ділення `a` на `b`.

Наприклад:

<Code>

1. `alert( 5 % 2 );` **// 1 — остача від ділення 5 на 2**
2. `alert( 8 % 3 );` **// 2 — остача від ділення 8 на 3**

</Code>

### Піднесення до степеня `**`

Оператор піднесення до степеня `a ** b` множить a саме на себе `b` разів.

У школі ми записуємо це як `ab`.

Наприклад:

<Code>

1. `alert( 2 ** 2 );` **// 2² = 4**
2. `alert( 2 ** 3 );` **// 2³ = 8**
3. `alert( 2 ** 4 );` **// 2⁴ = 16**

</Code>

Так само як у математиці, оператор піднесення також можна використовувати для дробових чисел.

Наприклад, квадратний корінь це піднесення до степеня `½`:

<Code>

1. `alert( 4 ** (1/2) );`** // 2 (степінь 1/2 — це теж саме, що квадратний корінь)**
2. `alert( 8 ** (1/3) );` **// 2 (степінь 1/3 — це теж саме, що кубічний корінь)**

</Code>

</Column>

<Column id="obyednannya-ryadkiv-cherez-binarnii">
## Об’єднання рядків через бінарний +

БРозглянемо особливості операторів JavaScript, які виходять за межі шкільної арифметики.

Зазвичай оператор плюс `+` додає числа.

Але якщо бінарний `+` застосовується до рядків, він об’єднує їх:

<Code>

1. `let s = 'мій_' + 'рядок';`
2. `alert(s);` **// мій_рядок**

</Code>

Зверніть увагу, якщо будь-який з операндів є рядком, тоді інший також перетворюється на рядок

<Code>

1. `alert( '1' + 2 );` **// "12"**
2. `alert( 2 + '1' );` **// "21"**

</Code>

Бачите, не має значення, чи перший операнд – рядок, чи другий.

Ось складніший приклад:

<Code>

1. `alert(2 + 2 + '1' );` **// "41", а не "221"**

</Code>

Тут оператори виконуються один за одним. Перший + додає два числа, тому він поверне 4; а наступний оператор + вже додасть (об’єднає) попередній результат із рядком 1. У підсумку ми отримаємо рядок '41' (4 + '1').

<Code>

1. `alert('1' + 2 + 2);` **// "122", а не "14"**

</Code>

У цьому прикладі перший операнд – рядок, тому компілятор також опрацьовує інші два операнди як рядки. Операнд 2 приєднується (конкатенується) до `'1'`, тому в результаті буде `'1' + 2 = "12"`, а потім — `"12" + 2 = "122"`.

Лише бінарний `+` працює з рядками так. Інші арифметичні оператори працюють тільки з числами й завжди перетворюють свої операнди на числа.

Ось приклад, як працює віднімання й ділення:

<Code>

1. `alert( 6 - '2' );` **// 4, '2' перетворюється на число**
2. `alert( '6' / '2' );` **// 3, обидва операнди перетворюються на числа**

</Code>

</Column>

<Column id ="chislove-peretvorennya-unarnii">
## Числове перетворення, унарний +

У оператора плюс `+` є дві форми: бінарна, яку ми використовували вище, та унарна.

Унарний плюс або, іншими словами, оператор плюс `+`, застосований до одного операнда, нічого не зробить, якщо операнд є числом. Але якщо операнд не є числом, унарний плюс перетворить його на число.

Наприклад:

<Code>

1. **// Нема ніякого впливу на числа**
2. `let x = 1;`
3. `alert( +x );` **// 1**
4.
5. `let y = -2;`
6. `alert( +y );` **// -2**
7.
8. **// Перетворює нечислові значення**
9. `alert( +true );` **// 1**
10. `alert( +"" );` **// 0**

</Code>

Він насправді працює як і Number(...), але має коротший вигляд.

Необхідність перетворення рядків на числа виникає дуже часто. Наприклад, якщо ми отримуємо значення з полів HTML форми, вони зазвичай є рядками. Що робити, якщо ми хочемо їх підсумувати?

Бінарний плюс додав би їх як рядки:

<Code>

1. `let apples = "2";`
2. `let oranges = "3";`
3. `alert( apples + oranges );` **// "23", бінарний плюс об’єднує рядки**

</Code>

Якщо ми хочемо використовувати їх як числа, нам потрібно конвертувати, а потім підсумувати їх:

<Code>

1. `let apples = "2";`
2. `let oranges = "3";`
3.
4. **// обидва значення перетворюються на числа перед застосуванням бінарного плюса**
5. `alert( +apples + +oranges );` **// 5**
6.
7. **// довший варіант** 8.**// alert( Number(apples) + Number(oranges) ); // 5**

</Code>

З погляду математика надмірні плюси можуть здатися дивними. Але з погляду програміста тут немає нічого особливого: спочатку застосовуються унарні плюси, вони перетворюють рядки на числа, а потім бінарний плюс підсумовує їх.

Чому унарні плюси застосовуються до значень перед бінарними плюсами? Як ми побачимо далі, це пов’язано з їхнім вищим `пріоритетом`.

</Column>

<Column id ="prioritet-operatora">
## Пріоритет оператора

Якщо вираз має більше одного оператора, порядок виконання визначається їхнім пріоритетом, або, іншими словами, типовим порядком першості операторів.

Зі школи ми всі знаємо, що множення у виразі `1 + 2 * 2` має бути обчислене перед додаванням. Саме це і є пріоритетом. Кажуть, що множення має вищий пріоритет, ніж додавання.

Дужки перевизначають будь-який пріоритет, тому, якщо ми не задоволені типовим пріоритетом, ми можемо використовувати дужки, щоби змінити його. Наприклад: `(1 + 2) * 2.`

У JavaScript є багато операторів. Кожен оператор має відповідний номер пріоритету. Першим виконується той оператор, який має найбільший номер пріоритету. Якщо пріоритет є однаковим, порядок виконання — зліва направо.

Ось витяг із [таблиці пріоритетів]("https://developer.mozilla.org/uk/docs/Web/JavaScript/Reference/Operators/Operator_Precedence") (вам не потрібно її запам’ятовувати, але зверніть увагу, що унарні оператори мають вищий пріоритет за відповідні бінарні).

Як ми бачимо, “унарний плюс” має пріоритет 15, що вище за 12 – пріоритет “додавання” (бінарний плюс). Саме тому, у виразі "+apples + +oranges", унарні плюси виконуються перед додаванням (бінарним плюсом).

</Column>

<Column id ="prisvoyennya">
## Присвоєння

Зазначимо, що присвоєння `=` також є оператором. Воно є у таблиці з пріоритетами й має дуже низький пріоритет `2`.

Тому, коли ми присвоюємо значення змінній, наприклад, `x = 2 * 2 + 1`, спочатку виконуються обчислення, а потім виконується присвоєння `=` зі збереженням результату в `x`.

<Code>

1. `let x = 2 * 2 + 1;`
2.
3. `alert( x );` **// 5**

</Code>

### Присвоєння = повертає результат

Той факт, що `=` є оператором, а не “магічною” конструкцією мови, має цікаве значення.

Усі оператори в JavaScript повертають значення. Це очевидно для `+` та `-`, але це також правдиво для `=`.

Виклик `x = значення` записує значення у `x`, а потім повертає його.

Ось демонстрація, яка використовує присвоєння як частину складнішого виразу:

<Code>

1. `let a = 1;`
2. `let b = 2;`
3.
4. `let c = 3 - (a = b + 1);`
5.
6. `alert( a );` **// 3**
7. `alert( c );` **// 0**

</Code>

У наведеному вище прикладі результат виразу `(a = b + 1)` є значенням, яке присвоювалося змінній `a` (тобто `3`). Потім воно використовується для подальших обчислень.

Чудернацький код, чи не так? Ми маємо розуміти, як це працює, бо іноді ми бачимо подібне в бібліотеках JavaScript.

Однак, будь ласка, не пишіть свій код так. Ці трюки, безумовно, не роблять код більш зрозумілим або читабельним.

### Ланцюгові присвоєння

Іншою цікавою особливістю є здатність ланцюгового присвоєння:

<Code>

1. `let a, b, c;`
2.
3. `a = b = c = 2 + 2;`
4.
5. `alert( a ); `**// 4**
6. `alert( b );` **// 4**
7. `alert( c );`**// 4**

</Code>

Ланцюгове присвоєння виконується справа наліво. Спочатку обчислюється найправіший вираз `2 + 2`, а потім результат присвоюється змінним ліворуч:` c, b та a`. Зрештою всі змінні мають спільне значення.

Знову таки, щоби покращити читабельність коду, краще розділяти подібні конструкції на декілька рядків:

<Code>

1. `c = 2 + 2;`
2. `b = c;`
3. `a = c;`

</Code>

Так легше прочитати, особливо коли швидко переглядати код.

</Column>
