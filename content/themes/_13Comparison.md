---
MainTheme: "Оператори порівняння"

PageThemes:
  [
    {
      name: "Результат порівняння має логічний тип",
      url: "rezultat-porivnyannya-maye-logichnii-tip",
    },
    { name: "Порівняння рядків", url: "porivnyannya-ryadkiv" },
    { name: "Порівняння різних типів", url: "porivnyannya-riznikh-tipiv" },
    { name: "Строге порівняння", url: "stroge-porivnyannya" },
    {
      name: "Порівняння з null і undefined",
      url: "porivnyannya-z-null-i-undefined",
    },
    { name: "Підсумки", url: "pidsumki" },
  ]

Test: "true"
---

<Column>
# Оператори порівняння

Багато з операторів порівняння нам відомі з математики.

В JavaScript вони записуються ось так:

Більше/менше: `a > b`, `a < b`.
Більше/менше або дорівнює: `a >= b, a <= b`.
Дорівнює: `a == b`. Зверніть увагу, для порівняння потрібно використовувати два знаки рівності `==`. Один знак рівності `a = b` означав б присвоєння.
Не дорівнює: в математиці позначається символом `≠`, проте в JavaScript записується як `a != b`.
В цьому розділі ми вивчимо різні типи порівнянь, дізнаємось, як JavaScript їх виконує, та розглянемо важливі особливості.

В кінці ви знайдете корисні поради, як уникати специфічних “примх” JavaScript.

</Column>

<Column id="rezultat-porivnyannya-maye-logichnii-tip">
## Результат порівняння має логічний тип

Всі оператори порівняння повертають значення логічного типу:

- `true` – означає “так”, “правильно” або “істина”.
- `false` – означає “ні”, “неправильно” або “хибність”.

Наприклад:

<Code>

1. `alert( 2 > 1 );` **// true (правильно)**
2. `alert( 2 == 1 );` **// false (неправильно)**
3. `alert( 2 != 1 );` **// true (правильно)**

</Code>

Результат порівняння можна присвоїти змінній, як і будь-яке інше значення:

<Code>

1. `let result = 5 > 4;` **// присвоїти результат порівняння змінній result**
2. `alert( result );` **// true**

</Code>

</Column>

<Column id="porivnyannya-ryadkiv">
## Порівняння рядків

Щоб визначити, чи один рядок більший за інший, JavaScript використовує так званий “алфавітний” або “лексикографічний” порядок.

Інакше кажучи, рядки порівнюються посимвольно.

Наприклад:

<Code>

1. `alert( 'Я' > 'А' );` **// true**
2. `alert( 'Соки' > 'Сода' );` **// true**
3. `alert( 'Комар' > 'Кома' );` **// true**

</Code>

Алгоритм порівняння рядків досить простий:

- Порівнюються перші символи обох рядків.
- Якщо перший символ першого рядка більший (менший) за перший символ другого рядка, то перший рядок більший (менший) за другий. Порівняння закінчено.
- В іншому випадку, якщо перші символи обох рядків рівні, то таким самим чином порівнюються вже другі символи рядків.
- Порівняння продовжується до того часу, доки не закінчиться один з рядків.
- Якщо два рядки закінчуються одночасно, то вони рівні. Інакше, довший рядок вважатиметься більшим.

В прикладах вище, порівняння `'Я' > 'А'` завершиться на першому кроці.

Проте друге порівняння слів '`Соки' і 'Сода'` буде виконуватися посимвольно:

`С` дорівнює `С`.
`о` дорівнює `о`.
`к` більше ніж `д`. На цьому кроці порівнювання закінчується. Перший рядок більший.

<Extra>
### Використовується кодування Unicode, а не справжній алфавіт

Такий алгоритм порівняння схожий на алгоритм сортування, який використовується в словниках і телефонних довідниках, проте вони не зовсім однакові.

Наприклад, в JavaScript має значення регістр символів. Велика буква `"А"` не рівна маленькій `"а"`. Але яка з них більше? Маленька буква `"а"`. Чому? Тому що маленькі букви мають більший код у внутрішній таблиці кодування, яку використовує JavaScript (Unicode). Ми розглянемо особливості і наслідки цього кодування в розділі Рядки.

</Extra>

</Column>

<Column id="porivnyannya-riznikh-tipiv">
## Порівняння різних типів

Коли порівнюються значення різних типів, JavaScript конвертує ці значення в числа.

Наприклад:
<Code>

1. `alert( '2' > 1 );` **// true, рядок '2' стає числом 2**
2. `alert( '01' == 1 );` **// true, рядок '01' стає числом 1**

</Code>

Логічне значення `true` стає `1`, а `false` — `0`.

Наприклад:

<Code>

1. `alert( true == 1 );` **// true**
2. `alert( false == 0 );` **// true**

</Code>

<Extra>
### Кумедний наслідок

Можлива наступна ситуація:

- ва значення рівні.
- Одне з них true як логічне значення, а інше — false.

Наприклад:

<Code>

1. `let a = 0;`
2. `alert( Boolean(a) );` **// false**
3.
4. `let b = "0";`
5. `alert( Boolean(b) );` **// true**
6.
7. `alert(a == b);` \*\*//

</Code>

З погляду JavaScript, результат очікуваний. Порівняння перетворює значення на числа (тому "0" стає 0), тоді як явне перетворення за допомогою Boolean використовує інший набір правил.

</Extra>

</Column>

<Column id ="stroge-porivnyannya">
## Строге порівняння

Використання звичайного оператора порівняння `==` може викликати проблеми. Наприклад, він не відрізняє `0` від `false`:

<Code>

1. `alert( 0 == false );` **// true**

</Code>

Така ж проблема станеться з пустим рядком:

<Code>

1. `let apples = "2";`
2. `let oranges = "3";`
3. `alert( apples + oranges );` **// "23", бінарний плюс об’єднує рядки**

</Code>

Якщо ми хочемо використовувати їх як числа, нам потрібно конвертувати, а потім підсумувати їх:

<Code>

1. `alert( '' == false );` **// true**

</Code>

Це відбувається тому, що операнди різних типів перетворюються оператором порівняння `==` на числа. Пустий рядок, так само як `false`, стане нулем.

Як тоді відрізнити 0 від `false`?

Оператор строгої рівності `===` перевіряє рівність без перетворення типів.

Іншими словами, якщо `a і b` мають різні типи, то перевірка `a` `===` `b` негайно поверне результат `false` без спроби їхнього перетворення.

Давайте перевіримо:
<Code>

1. `alert( 0 === false );` **// false, тому що порівнюються різні типи**

</Code>

Є також оператор строгої нерівності `!==`, аналогічний до `!=`.

Оператор строгої рівності довше писати, проте він робить код більш зрозумілим і залишає менше місця для помилок.

</Column>

<Column id ="porivnyannya-z-null-i-undefined">
## Порівняння з null і undefined

Поведінка `null` і `undefined` під час порівняння з іншими значеннями — особливе:

При строгому порівнянні `===`
Ці значення різні, тому що різні їхні типи.

<Code>

1. `alert( null === undefined );` **// false**

</Code>

При нестрогому порівнянні `==`
Ці значення рівні. Водночас ці значення не рівні значенням інших типів. Це спеціальне правило мови.

<Code>

1. `alert( null == undefined );` **// true**

</Code>

Під час використання математичних операторів та інших операторів порівняння `<` `>` `<=` `>=`
Значення `null/undefined` конвертуються в числа: `null` стає `0`, тоді як `undefined` стає `NaN`.

Тепер глянемо, які кумедні речі трапляються, коли ми застосовуємо ці правила. І, що більш важливо, як уникнути помилок під час їхнього використання.

### Дивний результат порівняння `null` і `0`

Порівняємо `null` з нулем:

<Code>

1. `alert( null > 0 );` **// (1) false**
2. `alert( null == 0 );`**// (2) false**
3. `alert( null >= 0 );` **// (3) true**

</Code>

З погляду математики це дивно. Результат останнього порівняння показує, що "`null` більше або дорівнює нулю", в такому випадку результат одного з порівнянь вище повинен бути `true`, але вони обидва `false`.

Причина в тому що нестроге порівняння `==` і порівняння `>` `<` `>=` `<=` працюють по-різному. Останні оператори конвертують null в число, розглядаючи його як `0`. Ось чому вираз (3) `null >= 0 `дає `true`, а вираз (1) `null > 0` — `false.`

З іншого боку, для нестрогого порівняння `==` значень `undefined` і `null` діє окреме правило: ці значення не перетворюються на інші типи, вони рівні один одному і не рівні будь-чому іншому. Ось чому вираз (2) `null == 0` повертає результат `false`.

### Не порівнюйте значення `undefined`

Значення ё не має порівнюватись з іншими значеннями:
<Code>

1. `alert( undefined > 0 );` **// false (1)**
2. `alert( undefined < 0 );` **// false (2)**
3. `alert( undefined == 0 );` **// false (3)**

</Code>

Чому тоді порівняння undefined з нулем завжди повертає `false`?

Ми отримуємо такі результати, тому що:

- Порівняння (1) і (2) повертає false, тому що `undefined` під час порівняння з `“не null”` значеннями завжди конвертується в `NaN`, а `NaN` — це спеціальне числове значення, яке завжди повертає `false` під час будь-яких порівнянь.
- Нестроге порівняння (3) повертає `false`, тому що `undefined` рівне тільки `null`, `undefined` і жодним іншим значенням.

### Як уникати проблем

Чому ми переглядали ці приклади? Чи повинні ми постійно пам’ятати про всі ці особливості? Не обов’язково. З часом всі ці заплутані правила стануть для вас знайомими, але можна уникнути проблем, якщо дотримуватися надійних правил:

- Будьте пильні під час порівняння будь-якого значення з `undefined/null`, за винятком строгого порівняння `===.`
- Не використовуйте порівняння `>=` `>` `<` `<=` зі змінними, які можуть приймати значення `null/undefined`, хіба що ви цілком впевнені в тому, що робите. Якщо змінна може приймати ці значення, то додайте для них окремі перевірки.

</Column>

<Column id ="pidsumki">
## Підсумки

- Оператори порівняння повертають значення логічного типу.
- Рядки порівнюються посимвольно в лексикографічному порядку.
- Значення різних типів під час порівняння конвертуються в числа. Винятками є порівняння за допомогою операторів строгої рівності/нерівності.
- Значення `null і undefined` рівні `==` один одному і не рівні будь-якому іншому значенню.
- Будьте обережні, використовуючи оператори порівняння на зразок `>` чи `<` зі змінними, які можуть приймати значення `null/undefined`. Хорошою ідеєю буде зробити окрему перевірку на n`ull/undefined` для таких значень.

</Column>
